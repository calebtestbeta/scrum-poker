// 遊戲整合邏輯 - 連接所有管理器和 UI 元素
// 全域函數供 HTML 呼叫

// 開始遊戲
async function startGame() {\n    const playerName = document.getElementById('playerName').value.trim();\n    const playerRole = document.getElementById('playerRole').value;\n    const roomId = document.getElementById('roomId').value.trim();\n    \n    // 驗證輸入\n    if (!playerName) {\n        uiManager.showError('請輸入你的名字');\n        return;\n    }\n    \n    try {\n        // 設定載入狀態\n        gameState = 'loading';\n        \n        // 初始化 Firebase 設定\n        const config = await getFirebaseConfig();\n        \n        // 初始化 Firebase Manager\n        await firebaseManager.initialize(config);\n        \n        // 設定 Firebase 回調\n        setupFirebaseCallbacks();\n        \n        // 加入房間\n        const result = await firebaseManager.joinRoom(roomId, playerName, playerRole);\n        \n        if (result) {\n            // 建立當前玩家\n            currentPlayer = {\n                id: result.playerId,\n                name: playerName,\n                role: playerRole\n            };\n            \n            // 在遊戲桌面新增玩家\n            gameTable.addPlayer(result.playerId, playerName, playerRole);\n            \n            // 啟動 UI\n            uiManager.startGame(result.roomId, result.playerId);\n            \n            console.log('🎮 遊戲啟動成功');\n        } else {\n            throw new Error('無法加入房間');\n        }\n        \n    } catch (error) {\n        console.error('啟動遊戲失敗:', error);\n        uiManager.showError('啟動遊戲失敗: ' + error.message);\n        gameState = 'login';\n    }\n}\n\n// 開牌\nfunction revealCards() {\n    if (!gameTable || !firebaseManager) {\n        console.warn('遊戲未初始化');\n        return;\n    }\n    \n    // 觸發動畫效果\n    animationManager.flash(color(251, 191, 36), 200);\n    animationManager.shake(5, 300);\n    \n    // 執行開牌\n    gameTable.revealCards();\n    firebaseManager.revealCards();\n    \n    uiManager.showSuccess('開牌！');\n}\n\n// 清除投票\nfunction clearVotes() {\n    if (!gameTable || !firebaseManager) {\n        console.warn('遊戲未初始化');\n        return;\n    }\n    \n    // 執行清除\n    gameTable.clearVotes();\n    firebaseManager.clearVotes();\n    \n    // 重設 UI 統計\n    uiManager.resetStatistics();\n    \n    uiManager.showSuccess('重新開始！');\n}\n\n// 離開遊戲\nfunction leaveGame() {\n    if (firebaseManager) {\n        firebaseManager.leaveRoom();\n    }\n    \n    // 清除遊戲狀態\n    currentPlayer = null;\n    \n    // 重設遊戲桌面\n    if (gameTable) {\n        gameTable.players = [];\n    }\n    \n    // 清除動畫效果\n    animationManager.clearAllEffects();\n    \n    // 結束 UI\n    uiManager.endGame();\n    \n    console.log('👋 離開遊戲');\n}\n\n// 儲存 Firebase 設定\nfunction saveFirebaseConfig() {\n    const projectId = document.getElementById('projectId').value.trim();\n    const apiKey = document.getElementById('apiKey').value.trim();\n    \n    if (!projectId || !apiKey) {\n        uiManager.showError('請填寫完整的 Firebase 設定');\n        return;\n    }\n    \n    // 儲存到 localStorage\n    const config = { projectId, apiKey };\n    localStorage.setItem('scrumPokerConfig', JSON.stringify(config));\n    localStorage.removeItem('scrumPokerMode'); // 清除本地模式標記\n    \n    // 隱藏設定區域\n    const configSection = document.querySelector('.firebase-config');\n    if (configSection) {\n        configSection.style.display = 'none';\n    }\n    \n    uiManager.showSuccess('Firebase 設定已儲存！');\n}\n\n// 使用本地模式\nfunction useLocalMode() {\n    // 清除 Firebase 設定\n    localStorage.removeItem('scrumPokerConfig');\n    localStorage.setItem('scrumPokerMode', 'local');\n    \n    // 隱藏設定區域\n    const configSection = document.querySelector('.firebase-config');\n    if (configSection) {\n        configSection.style.display = 'none';\n    }\n    \n    uiManager.showSuccess('已切換到本地模式！');\n}\n\n// 取得 Firebase 設定\nasync function getFirebaseConfig() {\n    const savedConfig = localStorage.getItem('scrumPokerConfig');\n    const savedMode = localStorage.getItem('scrumPokerMode');\n    \n    if (savedConfig) {\n        return JSON.parse(savedConfig);\n    } else if (savedMode === 'local') {\n        return null; // 使用本地模式\n    } else {\n        // 檢查是否有全域設定（從 firebase-config.js）\n        if (typeof window.FIREBASE_CONFIG !== 'undefined') {\n            return window.FIREBASE_CONFIG;\n        }\n        return null;\n    }\n}\n\n// 設定 Firebase 回調函數\nfunction setupFirebaseCallbacks() {\n    if (!firebaseManager) return;\n    \n    firebaseManager.setCallbacks({\n        onPlayerJoined: (playerData) => {\n            console.log('玩家加入:', playerData.name);\n            \n            // 在遊戲桌面新增玩家\n            if (gameTable && playerData.id !== currentPlayer?.id) {\n                gameTable.addPlayer(playerData.id, playerData.name, playerData.role);\n            }\n            \n            // 更新玩家數量\n            const totalPlayers = gameTable ? gameTable.players.length : 0;\n            uiManager.updatePlayerCount(totalPlayers);\n            \n            // 觸發加入動畫\n            if (animationManager && gameTable) {\n                const player = gameTable.players.find(p => p.id === playerData.id);\n                if (player) {\n                    animationManager.createCelebration(player.position.x, player.position.y);\n                }\n            }\n            \n            uiManager.showSuccess(`${playerData.name} 加入了遊戲`);\n        },\n        \n        onPlayerLeft: (playerData) => {\n            console.log('玩家離開:', playerData.name);\n            \n            // 從遊戲桌面移除玩家\n            if (gameTable) {\n                gameTable.removePlayer(playerData.id);\n            }\n            \n            // 更新玩家數量\n            const totalPlayers = gameTable ? gameTable.players.length : 0;\n            uiManager.updatePlayerCount(totalPlayers);\n            \n            uiManager.showToast(`${playerData.name} 離開了遊戲`, 'info');\n        },\n        \n        onVoteUpdated: (playerData) => {\n            console.log('投票更新:', playerData.name, playerData.vote);\n            \n            // 更新遊戲桌面的玩家狀態\n            if (gameTable) {\n                const player = gameTable.players.find(p => p.id === playerData.id);\n                if (player && playerData.hasVoted) {\n                    player.setVote(playerData.vote);\n                    \n                    // 觸發投票動畫\n                    if (animationManager) {\n                        animationManager.createExplosion(player.position.x, player.position.y, 10);\n                    }\n                }\n                \n                // 更新投票進度\n                const votedCount = gameTable.players.filter(p => p.hasVoted).length;\n                const totalCount = gameTable.players.length;\n                uiManager.updateVotingProgress(votedCount, totalCount);\n            }\n        },\n        \n        onGameStateChanged: (roomData) => {\n            console.log('遊戲狀態變更:', roomData.phase);\n            \n            if (roomData.phase === 'revealing') {\n                // 開牌階段\n                uiManager.updateGameStatus('revealing');\n                \n                if (gameTable) {\n                    gameTable.gamePhase = 'revealing';\n                    gameTable.revealStartTime = millis();\n                }\n                \n                // 觸發開牌動畫\n                if (animationManager) {\n                    animationManager.flash(color(34, 197, 94), 500);\n                    animationManager.shake(8, 400);\n                }\n            } else if (roomData.phase === 'voting') {\n                // 投票階段\n                uiManager.updateGameStatus('voting');\n                \n                if (gameTable) {\n                    gameTable.gamePhase = 'voting';\n                }\n            } else if (roomData.phase === 'finished') {\n                // 完成階段\n                uiManager.updateGameStatus('finished');\n                \n                if (gameTable) {\n                    gameTable.gamePhase = 'finished';\n                }\n                \n                // 更新統計資料\n                if (roomData.votes) {\n                    const votes = Object.values(roomData.votes);\n                    uiManager.updateStatistics(votes);\n                }\n                \n                // 觸發慶祝動畫\n                if (animationManager && gameTable) {\n                    for (const player of gameTable.players) {\n                        if (player.hasVoted) {\n                            setTimeout(() => {\n                                animationManager.createCelebration(player.position.x, player.position.y);\n                            }, Math.random() * 1000);\n                        }\n                    }\n                }\n            }\n        },\n        \n        onError: (errorMessage) => {\n            console.error('Firebase 錯誤:', errorMessage);\n            uiManager.showError(errorMessage);\n        }\n    });\n}\n\n// Scrum Master 建議系統\nclass ScrumMasterAdvice {\n    constructor() {\n        this.suggestions = [];\n        this.isVisible = false;\n    }\n    \n    // 分析投票結果並產生建議\n    analyzeVotes(votes) {\n        this.suggestions = [];\n        \n        if (votes.length === 0) return;\n        \n        const numericVotes = votes.filter(v => typeof v.value === 'number');\n        const devVotes = numericVotes.filter(v => v.playerRole === 'dev');\n        const qaVotes = numericVotes.filter(v => v.playerRole === 'qa');\n        \n        // 計算統計數據\n        const allAverage = numericVotes.reduce((sum, v) => sum + v.value, 0) / numericVotes.length;\n        const devAverage = devVotes.length > 0 ? devVotes.reduce((sum, v) => sum + v.value, 0) / devVotes.length : 0;\n        const qaAverage = qaVotes.length > 0 ? qaVotes.reduce((sum, v) => sum + v.value, 0) / qaVotes.length : 0;\n        \n        const variance = numericVotes.reduce((sum, v) => sum + Math.pow(v.value - allAverage, 2), 0) / numericVotes.length;\n        const isHighVariance = variance > 4;\n        \n        // 產生建議\n        if (devVotes.length > 0 && qaVotes.length > 0) {\n            const devQaDiff = Math.abs(devAverage - qaAverage);\n            \n            if (devQaDiff > 3) {\n                if (devAverage > qaAverage) {\n                    this.suggestions.push({\n                        type: 'role_gap',\n                        title: '開發與測試估點差異較大',\n                        message: '開發團隊的估點明顯高於測試團隊，可能需要討論技術複雜度與測試策略的認知差異。',\n                        icon: '⚠️'\n                    });\n                } else {\n                    this.suggestions.push({\n                        type: 'role_gap',\n                        title: '測試估點高於開發估點',\n                        message: '測試團隊認為此功能測試複雜度較高，建議討論測試範圍與自動化測試的可能性。',\n                        icon: '🔍'\n                    });\n                }\n            }\n        }\n        \n        if (isHighVariance) {\n            this.suggestions.push({\n                type: 'high_variance',\n                title: '估點分歧較大',\n                message: '團隊對此功能的複雜度認知差異較大，建議進一步討論需求細節和實作方式。',\n                icon: '💭'\n            });\n        }\n        \n        if (allAverage > 8) {\n            this.suggestions.push({\n                type: 'high_complexity',\n                title: '高複雜度功能',\n                message: '此功能複雜度較高，建議考慮拆分成較小的 User Story，或分階段實作。',\n                icon: '🔨'\n            });\n        }\n        \n        if (numericVotes.length > 0 && variance < 1) {\n            this.suggestions.push({\n                type: 'good_consensus',\n                title: '團隊共識良好',\n                message: '團隊對此功能的複雜度認知一致，可以放心進行開發規劃。',\n                icon: '✅'\n            });\n        }\n        \n        // 特殊卡牌建議\n        const coffeeVotes = votes.filter(v => v.value === 'coffee');\n        const questionVotes = votes.filter(v => v.value === 'question');\n        \n        if (coffeeVotes.length > 0) {\n            this.suggestions.push({\n                type: 'break_needed',\n                title: '休息時間',\n                message: `${coffeeVotes.length} 位成員建議休息，考慮安排短暫休息後再繼續討論。`,\n                icon: '☕'\n            });\n        }\n        \n        if (questionVotes.length > 0) {\n            this.suggestions.push({\n                type: 'unclear_requirements',\n                title: '需求不明確',\n                message: `${questionVotes.length} 位成員對需求有疑問，建議先澄清需求細節再重新估點。`,\n                icon: '❓'\n            });\n        }\n    }\n    \n    // 繪製建議面板\n    draw() {\n        if (!this.isVisible || this.suggestions.length === 0) return;\n        \n        push();\n        \n        // 背景\n        fill(0, 0, 0, 180);\n        noStroke();\n        rectMode(CORNER);\n        const panelWidth = 350;\n        const panelHeight = Math.min(400, this.suggestions.length * 80 + 60);\n        const panelX = width - panelWidth - 20;\n        const panelY = height - panelHeight - 100;\n        \n        rect(panelX, panelY, panelWidth, panelHeight, 15);\n        \n        // 標題\n        fill(GAME_CONFIG.colors.accent);\n        textAlign(LEFT, TOP);\n        textSize(18);\n        textStyle(BOLD);\n        text('🎯 Scrum Master 建議', panelX + 20, panelY + 20);\n        \n        // 建議列表\n        textStyle(NORMAL);\n        let currentY = panelY + 50;\n        \n        for (const suggestion of this.suggestions) {\n            // 圖示\n            textSize(20);\n            text(suggestion.icon, panelX + 20, currentY);\n            \n            // 標題\n            fill(255);\n            textSize(14);\n            textStyle(BOLD);\n            text(suggestion.title, panelX + 50, currentY);\n            \n            // 訊息\n            fill(200);\n            textSize(12);\n            textStyle(NORMAL);\n            const messageLines = this.wrapText(suggestion.message, panelWidth - 70);\n            for (let i = 0; i < messageLines.length; i++) {\n                text(messageLines[i], panelX + 50, currentY + 20 + i * 15);\n            }\n            \n            currentY += 70;\n        }\n        \n        pop();\n    }\n    \n    // 文字換行\n    wrapText(text, maxWidth) {\n        const words = text.split(' ');\n        const lines = [];\n        let currentLine = '';\n        \n        for (const word of words) {\n            const testLine = currentLine + (currentLine ? ' ' : '') + word;\n            if (textWidth(testLine) <= maxWidth) {\n                currentLine = testLine;\n            } else {\n                if (currentLine) {\n                    lines.push(currentLine);\n                }\n                currentLine = word;\n            }\n        }\n        \n        if (currentLine) {\n            lines.push(currentLine);\n        }\n        \n        return lines;\n    }\n    \n    // 顯示建議\n    show() {\n        this.isVisible = true;\n    }\n    \n    // 隱藏建議\n    hide() {\n        this.isVisible = false;\n    }\n    \n    // 切換顯示狀態\n    toggle() {\n        this.isVisible = !this.isVisible;\n    }\n}\n\n// 建立 Scrum Master 建議系統實例\nlet scrumMasterAdvice;\n\n// 當頁面載入完成時初始化\nwindow.addEventListener('DOMContentLoaded', () => {\n    scrumMasterAdvice = new ScrumMasterAdvice();\n    console.log('🎯 Scrum Master 建議系統已初始化');\n});\n\n// 在 UIManager 的 draw 方法中新增建議面板繪製\nif (typeof UIManager !== 'undefined') {\n    const originalDraw = UIManager.prototype.draw;\n    UIManager.prototype.draw = function() {\n        originalDraw.call(this);\n        \n        // 繪製 Scrum Master 建議\n        if (scrumMasterAdvice && this.gamePhase === 'finished') {\n            scrumMasterAdvice.draw();\n        }\n    };\n    \n    // 覆寫統計更新方法以包含建議分析\n    const originalUpdateStatistics = UIManager.prototype.updateStatistics;\n    UIManager.prototype.updateStatistics = function(votes) {\n        originalUpdateStatistics.call(this, votes);\n        \n        // 分析投票並產生建議\n        if (scrumMasterAdvice) {\n            scrumMasterAdvice.analyzeVotes(votes);\n            scrumMasterAdvice.show();\n        }\n    };\n}\n\n// 鍵盤快捷鍵處理\ndocument.addEventListener('keydown', (event) => {\n    if (gameState === 'game') {\n        // H 鍵切換建議面板\n        if (event.code === 'KeyH' && scrumMasterAdvice) {\n            scrumMasterAdvice.toggle();\n        }\n        \n        // 空白鍵開牌\n        if (event.code === 'Space') {\n            event.preventDefault();\n            revealCards();\n        }\n    }\n});\n\nconsole.log('🎮 遊戲整合邏輯已載入');\n