// 動畫管理器 - 處理全域動畫效果和視覺特效
class AnimationManager {
    constructor() {
        // 粒子系統
        this.particles = [];
        this.maxParticles = 200;
        
        // 螢幕效果
        this.screenEffects = {
            flash: {
                active: false,
                intensity: 0,
                color: null,
                duration: 0,
                startTime: 0
            },
            shake: {
                active: false,
                intensity: 0,
                duration: 0,
                startTime: 0,
                offsetX: 0,
                offsetY: 0
            },
            fade: {
                active: false,
                opacity: 0,
                targetOpacity: 0,
                speed: 0.05,
                color: null
            },
            zoom: {
                active: false,
                scale: 1,
                targetScale: 1,
                speed: 0.05,
                centerX: 0,
                centerY: 0
            }
        };
        
        // 背景動畫
        this.backgroundAnimation = {
            stars: [],
            meteors: [],
            floatingElements: []
        };
        
        // 轉場動畫
        this.transitions = {
            active: false,
            type: 'fade', // 'fade', 'slide', 'wipe', 'zoom'
            progress: 0,
            duration: 1000,
            startTime: 0,
            onComplete: null
        };
        
        // 性能設定
        this.performanceMode = 'high'; // 'low', 'medium', 'high'\n        this.frameSkip = 0;\n        this.targetFPS = 60;\n        \n        // 初始化背景元素\n        this.initializeBackgroundElements();\n        \n        console.log('✨ AnimationManager 已初始化');\n    }\n    \n    // 初始化背景元素\n    initializeBackgroundElements() {\n        // 初始化星星\n        for (let i = 0; i < 50; i++) {\n            this.backgroundAnimation.stars.push({\n                x: random(width),\n                y: random(height),\n                size: random(1, 3),\n                opacity: random(50, 255),\n                twinkleSpeed: random(0.01, 0.05),\n                twinklePhase: random(TWO_PI)\n            });\n        }\n        \n        // 初始化浮動元素\n        for (let i = 0; i < 20; i++) {\n            this.backgroundAnimation.floatingElements.push({\n                x: random(width),\n                y: random(height),\n                size: random(10, 30),\n                speed: random(0.1, 0.5),\n                angle: random(TWO_PI),\n                rotationSpeed: random(-0.02, 0.02),\n                opacity: random(10, 50),\n                type: random(['circle', 'triangle', 'diamond'])\n            });\n        }\n    }\n    \n    // 更新動畫\n    update() {\n        // 性能控制\n        if (this.performanceMode === 'low' && this.frameSkip++ % 2 !== 0) {\n            return;\n        }\n        \n        // 更新粒子\n        this.updateParticles();\n        \n        // 更新螢幕效果\n        this.updateScreenEffects();\n        \n        // 更新背景動畫\n        this.updateBackgroundAnimation();\n        \n        // 更新轉場動畫\n        this.updateTransitions();\n        \n        // 繪製效果\n        this.draw();\n    }\n    \n    // 更新粒子系統\n    updateParticles() {\n        for (let i = this.particles.length - 1; i >= 0; i--) {\n            const particle = this.particles[i];\n            \n            // 更新位置\n            particle.x += particle.vx;\n            particle.y += particle.vy;\n            \n            // 重力\n            if (particle.gravity) {\n                particle.vy += particle.gravity;\n            }\n            \n            // 阻力\n            if (particle.drag) {\n                particle.vx *= particle.drag;\n                particle.vy *= particle.drag;\n            }\n            \n            // 更新屬性\n            particle.life -= particle.decay;\n            particle.size *= particle.sizeDecay || 1;\n            particle.opacity = particle.life * particle.maxOpacity;\n            \n            // 移除死亡粒子\n            if (particle.life <= 0 || particle.size < 0.1) {\n                this.particles.splice(i, 1);\n            }\n        }\n    }\n    \n    // 更新螢幕效果\n    updateScreenEffects() {\n        const currentTime = millis();\n        \n        // 更新閃光效果\n        if (this.screenEffects.flash.active) {\n            const elapsed = currentTime - this.screenEffects.flash.startTime;\n            const progress = elapsed / this.screenEffects.flash.duration;\n            \n            if (progress >= 1) {\n                this.screenEffects.flash.active = false;\n                this.screenEffects.flash.intensity = 0;\n            } else {\n                // 閃光衰減\n                this.screenEffects.flash.intensity = (1 - progress) * 255;\n            }\n        }\n        \n        // 更新震動效果\n        if (this.screenEffects.shake.active) {\n            const elapsed = currentTime - this.screenEffects.shake.startTime;\n            const progress = elapsed / this.screenEffects.shake.duration;\n            \n            if (progress >= 1) {\n                this.screenEffects.shake.active = false;\n                this.screenEffects.shake.offsetX = 0;\n                this.screenEffects.shake.offsetY = 0;\n            } else {\n                const intensity = (1 - progress) * this.screenEffects.shake.intensity;\n                this.screenEffects.shake.offsetX = random(-intensity, intensity);\n                this.screenEffects.shake.offsetY = random(-intensity, intensity);\n            }\n        }\n        \n        // 更新淡入淡出效果\n        if (this.screenEffects.fade.active) {\n            const diff = this.screenEffects.fade.targetOpacity - this.screenEffects.fade.opacity;\n            this.screenEffects.fade.opacity += diff * this.screenEffects.fade.speed;\n            \n            if (Math.abs(diff) < 0.01) {\n                this.screenEffects.fade.opacity = this.screenEffects.fade.targetOpacity;\n                if (this.screenEffects.fade.opacity === 0) {\n                    this.screenEffects.fade.active = false;\n                }\n            }\n        }\n        \n        // 更新縮放效果\n        if (this.screenEffects.zoom.active) {\n            const diff = this.screenEffects.zoom.targetScale - this.screenEffects.zoom.scale;\n            this.screenEffects.zoom.scale += diff * this.screenEffects.zoom.speed;\n            \n            if (Math.abs(diff) < 0.001) {\n                this.screenEffects.zoom.scale = this.screenEffects.zoom.targetScale;\n                if (this.screenEffects.zoom.scale === 1) {\n                    this.screenEffects.zoom.active = false;\n                }\n            }\n        }\n    }\n    \n    // 更新背景動畫\n    updateBackgroundAnimation() {\n        // 更新星星閃爍\n        for (const star of this.backgroundAnimation.stars) {\n            star.twinklePhase += star.twinkleSpeed;\n            star.opacity = 100 + sin(star.twinklePhase) * 155;\n        }\n        \n        // 更新浮動元素\n        for (const element of this.backgroundAnimation.floatingElements) {\n            element.x += cos(element.angle) * element.speed;\n            element.y += sin(element.angle) * element.speed;\n            element.angle += element.rotationSpeed;\n            \n            // 邊界回繞\n            if (element.x < -50) element.x = width + 50;\n            if (element.x > width + 50) element.x = -50;\n            if (element.y < -50) element.y = height + 50;\n            if (element.y > height + 50) element.y = -50;\n        }\n        \n        // 更新流星\n        for (let i = this.backgroundAnimation.meteors.length - 1; i >= 0; i--) {\n            const meteor = this.backgroundAnimation.meteors[i];\n            meteor.x += meteor.vx;\n            meteor.y += meteor.vy;\n            meteor.life -= meteor.decay;\n            \n            if (meteor.life <= 0 || meteor.x > width + 100 || meteor.y > height + 100) {\n                this.backgroundAnimation.meteors.splice(i, 1);\n            }\n        }\n        \n        // 隨機產生流星\n        if (random() < 0.001 && this.backgroundAnimation.meteors.length < 3) {\n            this.createMeteor();\n        }\n    }\n    \n    // 更新轉場動畫\n    updateTransitions() {\n        if (!this.transitions.active) return;\n        \n        const currentTime = millis();\n        const elapsed = currentTime - this.transitions.startTime;\n        this.transitions.progress = Math.min(elapsed / this.transitions.duration, 1);\n        \n        if (this.transitions.progress >= 1) {\n            this.transitions.active = false;\n            if (this.transitions.onComplete) {\n                this.transitions.onComplete();\n            }\n        }\n    }\n    \n    // 繪製動畫效果\n    draw() {\n        push();\n        \n        // 套用震動效果\n        if (this.screenEffects.shake.active) {\n            translate(this.screenEffects.shake.offsetX, this.screenEffects.shake.offsetY);\n        }\n        \n        // 套用縮放效果\n        if (this.screenEffects.zoom.active) {\n            translate(this.screenEffects.zoom.centerX, this.screenEffects.zoom.centerY);\n            scale(this.screenEffects.zoom.scale);\n            translate(-this.screenEffects.zoom.centerX, -this.screenEffects.zoom.centerY);\n        }\n        \n        // 繪製背景動畫\n        this.drawBackgroundAnimation();\n        \n        // 繪製粒子\n        this.drawParticles();\n        \n        pop();\n        \n        // 繪製螢幕效果（不受變換影響）\n        this.drawScreenEffects();\n        \n        // 繪製轉場效果\n        this.drawTransitions();\n    }\n    \n    // 繪製背景動畫\n    drawBackgroundAnimation() {\n        if (this.performanceMode === 'low') return;\n        \n        // 繪製星星\n        for (const star of this.backgroundAnimation.stars) {\n            fill(255, star.opacity);\n            noStroke();\n            circle(star.x, star.y, star.size);\n        }\n        \n        // 繪製浮動元素\n        if (this.performanceMode === 'high') {\n            for (const element of this.backgroundAnimation.floatingElements) {\n                push();\n                translate(element.x, element.y);\n                rotate(element.angle);\n                fill(255, element.opacity);\n                noStroke();\n                \n                if (element.type === 'circle') {\n                    circle(0, 0, element.size);\n                } else if (element.type === 'triangle') {\n                    triangle(-element.size/2, element.size/2, \n                            element.size/2, element.size/2, \n                            0, -element.size/2);\n                } else if (element.type === 'diamond') {\n                    quad(0, -element.size/2, \n                         element.size/2, 0, \n                         0, element.size/2, \n                         -element.size/2, 0);\n                }\n                \n                pop();\n            }\n        }\n        \n        // 繪製流星\n        for (const meteor of this.backgroundAnimation.meteors) {\n            push();\n            stroke(255, meteor.life * 255);\n            strokeWeight(2);\n            const tailLength = 30;\n            line(meteor.x, meteor.y, \n                 meteor.x - meteor.vx * tailLength, \n                 meteor.y - meteor.vy * tailLength);\n            \n            // 流星頭部\n            fill(255, meteor.life * 255);\n            noStroke();\n            circle(meteor.x, meteor.y, 4);\n            pop();\n        }\n    }\n    \n    // 繪製粒子\n    drawParticles() {\n        for (const particle of this.particles) {\n            push();\n            translate(particle.x, particle.y);\n            \n            if (particle.rotation !== undefined) {\n                rotate(particle.rotation);\n            }\n            \n            fill(particle.color.r, particle.color.g, particle.color.b, particle.opacity);\n            noStroke();\n            \n            if (particle.shape === 'circle') {\n                circle(0, 0, particle.size);\n            } else if (particle.shape === 'square') {\n                rectMode(CENTER);\n                rect(0, 0, particle.size, particle.size);\n            } else if (particle.shape === 'triangle') {\n                triangle(-particle.size/2, particle.size/2, \n                        particle.size/2, particle.size/2, \n                        0, -particle.size/2);\n            }\n            \n            pop();\n        }\n    }\n    \n    // 繪製螢幕效果\n    drawScreenEffects() {\n        // 閃光效果\n        if (this.screenEffects.flash.active) {\n            push();\n            if (this.screenEffects.flash.color) {\n                fill(red(this.screenEffects.flash.color), \n                     green(this.screenEffects.flash.color), \n                     blue(this.screenEffects.flash.color), \n                     this.screenEffects.flash.intensity);\n            } else {\n                fill(255, this.screenEffects.flash.intensity);\n            }\n            noStroke();\n            rect(0, 0, width, height);\n            pop();\n        }\n        \n        // 淡入淡出效果\n        if (this.screenEffects.fade.active && this.screenEffects.fade.opacity > 0) {\n            push();\n            if (this.screenEffects.fade.color) {\n                fill(red(this.screenEffects.fade.color), \n                     green(this.screenEffects.fade.color), \n                     blue(this.screenEffects.fade.color), \n                     this.screenEffects.fade.opacity);\n            } else {\n                fill(0, this.screenEffects.fade.opacity);\n            }\n            noStroke();\n            rect(0, 0, width, height);\n            pop();\n        }\n    }\n    \n    // 繪製轉場效果\n    drawTransitions() {\n        if (!this.transitions.active) return;\n        \n        push();\n        const progress = this.easeInOutCubic(this.transitions.progress);\n        \n        if (this.transitions.type === 'fade') {\n            fill(0, progress * 255);\n            noStroke();\n            rect(0, 0, width, height);\n        } else if (this.transitions.type === 'slide') {\n            fill(0);\n            noStroke();\n            rect(0, 0, width * (1 - progress), height);\n        } else if (this.transitions.type === 'wipe') {\n            fill(0);\n            noStroke();\n            rect(0, 0, width, height * progress);\n        } else if (this.transitions.type === 'zoom') {\n            const scale = 1 + progress * 2;\n            const opacity = progress * 255;\n            translate(width/2, height/2);\n            scale(scale);\n            translate(-width/2, -height/2);\n            fill(0, opacity);\n            noStroke();\n            rect(0, 0, width, height);\n        }\n        \n        pop();\n    }\n    \n    // 建立粒子爆炸效果\n    createExplosion(x, y, count = 20, color = null) {\n        for (let i = 0; i < count; i++) {\n            const angle = (i / count) * TWO_PI;\n            const speed = random(2, 8);\n            const size = random(3, 12);\n            \n            this.particles.push({\n                x: x,\n                y: y,\n                vx: cos(angle) * speed,\n                vy: sin(angle) * speed,\n                size: size,\n                life: 1.0,\n                decay: random(0.01, 0.03),\n                maxOpacity: 255,\n                opacity: 255,\n                color: color || {\n                    r: random(100, 255),\n                    g: random(100, 255),\n                    b: random(100, 255)\n                },\n                shape: random(['circle', 'square', 'triangle']),\n                gravity: 0.1,\n                drag: 0.98,\n                sizeDecay: 0.99\n            });\n        }\n        \n        // 限制粒子數量\n        while (this.particles.length > this.maxParticles) {\n            this.particles.shift();\n        }\n    }\n    \n    // 建立慶祝效果\n    createCelebration(x, y) {\n        this.createExplosion(x, y, 30, color(251, 191, 36)); // 金色\n        \n        // 額外的彩色粒子\n        for (let i = 0; i < 10; i++) {\n            const angle = random(TWO_PI);\n            const speed = random(1, 4);\n            \n            this.particles.push({\n                x: x,\n                y: y,\n                vx: cos(angle) * speed,\n                vy: sin(angle) * speed - 2, // 向上偏移\n                size: random(5, 15),\n                life: 1.0,\n                decay: random(0.005, 0.015),\n                maxOpacity: 200,\n                opacity: 200,\n                color: {\n                    r: random(200, 255),\n                    g: random(200, 255),\n                    b: random(100, 255)\n                },\n                shape: 'circle',\n                gravity: 0.05,\n                drag: 0.99,\n                sizeDecay: 0.995\n            });\n        }\n    }\n    \n    // 建立流星\n    createMeteor() {\n        this.backgroundAnimation.meteors.push({\n            x: random(-50, width/2),\n            y: random(-50, height/2),\n            vx: random(2, 5),\n            vy: random(2, 5),\n            life: 1.0,\n            decay: 0.01\n        });\n    }\n    \n    // 觸發閃光效果\n    flash(color = null, duration = 300) {\n        this.screenEffects.flash.active = true;\n        this.screenEffects.flash.color = color;\n        this.screenEffects.flash.duration = duration;\n        this.screenEffects.flash.startTime = millis();\n        this.screenEffects.flash.intensity = 255;\n    }\n    \n    // 觸發震動效果\n    shake(intensity = 10, duration = 500) {\n        this.screenEffects.shake.active = true;\n        this.screenEffects.shake.intensity = intensity;\n        this.screenEffects.shake.duration = duration;\n        this.screenEffects.shake.startTime = millis();\n    }\n    \n    // 觸發淡入淡出效果\n    fade(targetOpacity, speed = 0.05, color = null) {\n        this.screenEffects.fade.active = true;\n        this.screenEffects.fade.targetOpacity = targetOpacity;\n        this.screenEffects.fade.speed = speed;\n        this.screenEffects.fade.color = color;\n    }\n    \n    // 觸發縮放效果\n    zoom(targetScale, speed = 0.05, centerX = width/2, centerY = height/2) {\n        this.screenEffects.zoom.active = true;\n        this.screenEffects.zoom.targetScale = targetScale;\n        this.screenEffects.zoom.speed = speed;\n        this.screenEffects.zoom.centerX = centerX;\n        this.screenEffects.zoom.centerY = centerY;\n    }\n    \n    // 開始轉場動畫\n    startTransition(type, duration = 1000, onComplete = null) {\n        this.transitions.active = true;\n        this.transitions.type = type;\n        this.transitions.duration = duration;\n        this.transitions.startTime = millis();\n        this.transitions.progress = 0;\n        this.transitions.onComplete = onComplete;\n    }\n    \n    // 設定性能模式\n    setPerformanceMode(mode) {\n        this.performanceMode = mode;\n        \n        if (mode === 'low') {\n            this.maxParticles = 50;\n        } else if (mode === 'medium') {\n            this.maxParticles = 100;\n        } else {\n            this.maxParticles = 200;\n        }\n        \n        // 清除多餘粒子\n        while (this.particles.length > this.maxParticles) {\n            this.particles.shift();\n        }\n    }\n    \n    // 清除所有效果\n    clearAllEffects() {\n        this.particles = [];\n        this.screenEffects.flash.active = false;\n        this.screenEffects.shake.active = false;\n        this.screenEffects.fade.active = false;\n        this.screenEffects.zoom.active = false;\n        this.transitions.active = false;\n    }\n    \n    // 緩動函數\n    easeInOutCubic(t) {\n        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n    }\n    \n    // 取得性能統計\n    getPerformanceStats() {\n        return {\n            particleCount: this.particles.length,\n            maxParticles: this.maxParticles,\n            performanceMode: this.performanceMode,\n            activeEffects: {\n                flash: this.screenEffects.flash.active,\n                shake: this.screenEffects.shake.active,\n                fade: this.screenEffects.fade.active,\n                zoom: this.screenEffects.zoom.active,\n                transition: this.transitions.active\n            }\n        };\n    }\n}\n