<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrum Poker æ•ˆèƒ½æ¸¬è©¦</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .metric {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .metric-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .test-result {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
        .pass { background: #d4edda; color: #155724; }
        .fail { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-size: 16px;
        }
        button:hover { background: #0056b3; }
        #perfChart {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 20px 0;
        }
        .browser-test {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .browser-item {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            border: 2px solid #ddd;
        }
        .browser-supported { border-color: #28a745; background: #d4edda; }
        .browser-partial { border-color: #ffc107; background: #fff3cd; }
        .browser-unsupported { border-color: #dc3545; background: #f8d7da; }
    </style>
</head>
<body>
    <h1>ğŸš€ Scrum Poker æ•ˆèƒ½æ¸¬è©¦å’Œè·¨ç€è¦½å™¨ç›¸å®¹æ€§</h1>
    
    <!-- æ•ˆèƒ½æ¸¬è©¦å€åŸŸ -->
    <div class="test-container">
        <h2>ğŸ“Š æ•ˆèƒ½æŒ‡æ¨™ç›£æ§</h2>
        <button onclick="runPerformanceTest()">é–‹å§‹æ•ˆèƒ½æ¸¬è©¦</button>
        <button onclick="runMemoryTest()">è¨˜æ†¶é«”æ¸¬è©¦</button>
        <button onclick="runAnimationTest()">å‹•ç•«æ•ˆèƒ½æ¸¬è©¦</button>
        
        <div class="metrics" id="performanceMetrics">
            <div class="metric">
                <div class="metric-value" id="loadTime">--</div>
                <div class="metric-label">é é¢è¼‰å…¥æ™‚é–“ (ms)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="domNodes">--</div>
                <div class="metric-label">DOM ç¯€é»æ•¸é‡</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="memoryUsage">--</div>
                <div class="metric-label">è¨˜æ†¶é«”ä½¿ç”¨ (MB)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="fps">--</div>
                <div class="metric-label">å‹•ç•« FPS</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="paintTime">--</div>
                <div class="metric-label">é‡ç¹ªæ™‚é–“ (ms)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="layoutTime">--</div>
                <div class="metric-label">é‡æ’æ™‚é–“ (ms)</div>
            </div>
        </div>
        
        <canvas id="perfChart"></canvas>
        
        <div id="testResults"></div>
    </div>
    
    <!-- è·¨ç€è¦½å™¨ç›¸å®¹æ€§æ¸¬è©¦ -->
    <div class="test-container">
        <h2>ğŸŒ è·¨ç€è¦½å™¨ç›¸å®¹æ€§æ¸¬è©¦</h2>
        <button onclick="runCompatibilityTest()">é–‹å§‹ç›¸å®¹æ€§æ¸¬è©¦</button>
        
        <div class="browser-test" id="browserCompatibility">
            <div class="browser-item" id="chrome">
                <strong>Chrome</strong><br>
                <span id="chromeVersion">--</span><br>
                <span id="chromeStatus">æª¢æ¸¬ä¸­...</span>
            </div>
            <div class="browser-item" id="firefox">
                <strong>Firefox</strong><br>
                <span id="firefoxVersion">--</span><br>
                <span id="firefoxStatus">æª¢æ¸¬ä¸­...</span>
            </div>
            <div class="browser-item" id="safari">
                <strong>Safari</strong><br>
                <span id="safariVersion">--</span><br>
                <span id="safariStatus">æª¢æ¸¬ä¸­...</span>
            </div>
            <div class="browser-item" id="edge">
                <strong>Edge</strong><br>
                <span id="edgeVersion">--</span><br>
                <span id="edgeStatus">æª¢æ¸¬ä¸­...</span>
            </div>
        </div>
        
        <div id="compatibilityResults"></div>
    </div>
    
    <!-- ç§»å‹•è£ç½®æ¸¬è©¦ -->
    <div class="test-container">
        <h2>ğŸ“± ç§»å‹•è£ç½®æ•ˆèƒ½æ¸¬è©¦</h2>
        <button onclick="runMobileTest()">é–‹å§‹ç§»å‹•æ¸¬è©¦</button>
        
        <div class="metrics" id="mobileMetrics">
            <div class="metric">
                <div class="metric-value" id="touchLatency">--</div>
                <div class="metric-label">è§¸æ§å»¶é² (ms)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="scrollPerf">--</div>
                <div class="metric-label">æ»¾å‹•æ•ˆèƒ½</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="networkSpeed">--</div>
                <div class="metric-label">ç¶²è·¯é€Ÿåº¦</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="batteryImpact">--</div>
                <div class="metric-label">é›»æ± å½±éŸ¿</div>
            </div>
        </div>
        
        <div id="mobileResults"></div>
    </div>
    
    <!-- CSS åŠŸèƒ½æ¸¬è©¦ -->
    <div class="test-container">
        <h2>ğŸ¨ CSS åŠŸèƒ½æ¸¬è©¦</h2>
        <button onclick="runCSSTest()">æ¸¬è©¦ CSS åŠŸèƒ½</button>
        
        <div id="cssTestResults"></div>
    </div>

    <script>
        // æ•ˆèƒ½æ¸¬è©¦å·¥å…·
        class PerformanceTester {
            constructor() {
                this.testResults = [];
                this.chart = null;
            }
            
            // åŸ·è¡Œæ•ˆèƒ½æ¸¬è©¦
            async runPerformanceTest() {
                console.log('ğŸš€ é–‹å§‹æ•ˆèƒ½æ¸¬è©¦...');
                
                // æ¸¬è©¦é é¢è¼‰å…¥æ™‚é–“
                const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
                document.getElementById('loadTime').textContent = loadTime;
                
                // æ¸¬è©¦ DOM ç¯€é»æ•¸é‡
                const domNodes = document.querySelectorAll('*').length;
                document.getElementById('domNodes').textContent = domNodes;
                
                // æ¸¬è©¦è¨˜æ†¶é«”ä½¿ç”¨ï¼ˆå¦‚æœæ”¯æ´ï¼‰
                if (performance.memory) {
                    const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    document.getElementById('memoryUsage').textContent = memoryMB;
                }
                
                // æ¸¬è©¦é‡ç¹ªå’Œé‡æ’æ™‚é–“
                await this.measurePaintAndLayout();
                
                this.logResult('æ•ˆèƒ½æ¸¬è©¦å®Œæˆ', 'pass');
            }
            
            // æ¸¬è©¦å‹•ç•«æ•ˆèƒ½
            async runAnimationTest() {
                console.log('ğŸ¬ é–‹å§‹å‹•ç•«æ•ˆèƒ½æ¸¬è©¦...');
                
                let frameCount = 0;
                let startTime = performance.now();
                
                const measureFPS = () => {
                    frameCount++;
                    if (frameCount < 120) { // æ¸¬è©¦ 2 ç§’
                        requestAnimationFrame(measureFPS);
                    } else {
                        const endTime = performance.now();
                        const fps = Math.round(frameCount / ((endTime - startTime) / 1000));
                        document.getElementById('fps').textContent = fps;
                        
                        if (fps >= 60) {
                            this.logResult(`å‹•ç•«æ•ˆèƒ½å„ªç§€: ${fps} FPS`, 'pass');
                        } else if (fps >= 30) {
                            this.logResult(`å‹•ç•«æ•ˆèƒ½è‰¯å¥½: ${fps} FPS`, 'warning');
                        } else {
                            this.logResult(`å‹•ç•«æ•ˆèƒ½éœ€è¦æ”¹å–„: ${fps} FPS`, 'fail');
                        }
                    }
                };
                
                requestAnimationFrame(measureFPS);
            }
            
            // æ¸¬è©¦è¨˜æ†¶é«”æ´©æ¼
            async runMemoryTest() {
                console.log('ğŸ§  é–‹å§‹è¨˜æ†¶é«”æ¸¬è©¦...');
                
                if (!performance.memory) {
                    this.logResult('ç€è¦½å™¨ä¸æ”¯æ´è¨˜æ†¶é«”ç›£æ§', 'warning');
                    return;
                }
                
                const initialMemory = performance.memory.usedJSHeapSize;
                
                // æ¨¡æ“¬å¤§é‡ DOM æ“ä½œ
                for (let i = 0; i < 1000; i++) {
                    const div = document.createElement('div');
                    div.textContent = `æ¸¬è©¦ç¯€é» ${i}`;
                    document.body.appendChild(div);
                    document.body.removeChild(div);
                }
                
                // å¼·åˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœæ”¯æ´ï¼‰
                if (window.gc) {
                    window.gc();
                }
                
                setTimeout(() => {
                    const finalMemory = performance.memory.usedJSHeapSize;
                    const memoryLeak = finalMemory - initialMemory;
                    
                    if (memoryLeak < 100000) { // 100KB
                        this.logResult('è¨˜æ†¶é«”ç®¡ç†è‰¯å¥½', 'pass');
                    } else {
                        this.logResult(`å¯èƒ½æœ‰è¨˜æ†¶é«”æ´©æ¼: ${Math.round(memoryLeak/1024)}KB`, 'warning');
                    }
                }, 1000);
            }
            
            // æ¸¬é‡é‡ç¹ªå’Œé‡æ’
            async measurePaintAndLayout() {
                const observer = new PerformanceObserver((list) => {
                    let paintTime = 0;
                    let layoutTime = 0;
                    
                    for (const entry of list.getEntries()) {
                        if (entry.entryType === 'paint') {
                            paintTime = Math.round(entry.startTime);
                        } else if (entry.entryType === 'layout-shift') {
                            layoutTime = Math.round(entry.value * 1000);
                        }
                    }
                    
                    document.getElementById('paintTime').textContent = paintTime || '--';
                    document.getElementById('layoutTime').textContent = layoutTime || '--';
                });
                
                try {
                    observer.observe({ entryTypes: ['paint', 'layout-shift'] });
                } catch (e) {
                    console.warn('ç€è¦½å™¨ä¸æ”¯æ´æŸäº›æ•ˆèƒ½ç›£æ§åŠŸèƒ½');
                }
            }
            
            // è·¨ç€è¦½å™¨ç›¸å®¹æ€§æ¸¬è©¦
            runCompatibilityTest() {
                console.log('ğŸŒ é–‹å§‹è·¨ç€è¦½å™¨ç›¸å®¹æ€§æ¸¬è©¦...');
                
                const tests = [
                    { name: 'CSS Grid', test: () => CSS.supports('display', 'grid') },
                    { name: 'CSS Flexbox', test: () => CSS.supports('display', 'flex') },
                    { name: 'CSS Custom Properties', test: () => CSS.supports('--custom-property', 'value') },
                    { name: 'Intersection Observer', test: () => 'IntersectionObserver' in window },
                    { name: 'Web Components', test: () => 'customElements' in window },
                    { name: 'Service Workers', test: () => 'serviceWorker' in navigator },
                    { name: 'LocalStorage', test: () => 'localStorage' in window },
                    { name: 'WebGL', test: () => {
                        const canvas = document.createElement('canvas');
                        return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                    }},
                    { name: 'WebSocket', test: () => 'WebSocket' in window },
                    { name: 'Fetch API', test: () => 'fetch' in window }
                ];
                
                const resultsDiv = document.getElementById('compatibilityResults');
                resultsDiv.innerHTML = '';
                
                // æª¢æ¸¬ç•¶å‰ç€è¦½å™¨
                const userAgent = navigator.userAgent;
                let browserName = 'Unknown';
                let browserVersion = 'Unknown';
                
                if (userAgent.includes('Chrome')) {
                    browserName = 'Chrome';
                    browserVersion = userAgent.match(/Chrome\/([0-9.]+)/)?.[1] || 'Unknown';
                } else if (userAgent.includes('Firefox')) {
                    browserName = 'Firefox';
                    browserVersion = userAgent.match(/Firefox\/([0-9.]+)/)?.[1] || 'Unknown';
                } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                    browserName = 'Safari';
                    browserVersion = userAgent.match(/Version\/([0-9.]+)/)?.[1] || 'Unknown';
                } else if (userAgent.includes('Edge')) {
                    browserName = 'Edge';
                    browserVersion = userAgent.match(/Edge\/([0-9.]+)/)?.[1] || 'Unknown';
                }
                
                // æ›´æ–°ç•¶å‰ç€è¦½å™¨è³‡è¨Š
                const currentBrowserId = browserName.toLowerCase();
                const browserElement = document.getElementById(currentBrowserId);
                if (browserElement) {
                    const versionElement = document.getElementById(`${currentBrowserId}Version`);
                    const statusElement = document.getElementById(`${currentBrowserId}Status`);
                    
                    if (versionElement) versionElement.textContent = browserVersion;
                    if (statusElement) statusElement.textContent = 'ç•¶å‰ç€è¦½å™¨';
                    
                    browserElement.className = 'browser-item browser-supported';
                }
                
                // åŸ·è¡ŒåŠŸèƒ½æ¸¬è©¦
                tests.forEach(test => {
                    try {
                        const result = test.test();
                        const className = result ? 'pass' : 'fail';
                        const status = result ? 'âœ… æ”¯æ´' : 'âŒ ä¸æ”¯æ´';
                        
                        resultsDiv.innerHTML += `
                            <div class="test-result ${className}">
                                <strong>${test.name}:</strong> ${status}
                            </div>
                        `;
                    } catch (error) {
                        resultsDiv.innerHTML += `
                            <div class="test-result fail">
                                <strong>${test.name}:</strong> âŒ æ¸¬è©¦å¤±æ•— (${error.message})
                            </div>
                        `;
                    }
                });
            }
            
            // ç§»å‹•è£ç½®æ•ˆèƒ½æ¸¬è©¦
            runMobileTest() {
                console.log('ğŸ“± é–‹å§‹ç§»å‹•è£ç½®æ¸¬è©¦...');
                
                // æª¢æ¸¬æ˜¯å¦ç‚ºç§»å‹•è£ç½®
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                if (!isMobile) {
                    this.logResult('ç•¶å‰éç§»å‹•è£ç½®ï¼ŒæŸäº›æ¸¬è©¦å¯èƒ½ä¸æº–ç¢º', 'warning', 'mobileResults');
                }
                
                // æ¸¬è©¦è§¸æ§å»¶é²
                this.testTouchLatency();
                
                // æ¸¬è©¦ç¶²è·¯é€Ÿåº¦
                this.testNetworkSpeed();
                
                // æ¸¬è©¦æ»¾å‹•æ•ˆèƒ½
                this.testScrollPerformance();
                
                // æª¢æ¸¬è¨­å‚™è³‡è¨Š
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                if (connection) {
                    document.getElementById('networkSpeed').textContent = connection.effectiveType || 'Unknown';
                }
                
                // é›»æ±  API æ¸¬è©¦
                if ('getBattery' in navigator) {
                    navigator.getBattery().then(battery => {
                        document.getElementById('batteryImpact').textContent = 
                            battery.charging ? 'å……é›»ä¸­' : `${Math.round(battery.level * 100)}%`;
                    });
                } else {
                    document.getElementById('batteryImpact').textContent = 'ä¸æ”¯æ´';
                }
            }
            
            // æ¸¬è©¦è§¸æ§å»¶é²
            testTouchLatency() {
                let touchStartTime = 0;
                let touchEndTime = 0;
                
                const testElement = document.createElement('div');
                testElement.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    width: 100px;
                    height: 100px;
                    background: #007bff;
                    transform: translate(-50%, -50%);
                    border-radius: 50%;
                    z-index: 10000;
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 12px;
                    cursor: pointer;
                `;
                testElement.textContent = 'é»æ“Šæ¸¬è©¦';
                
                const cleanup = () => {
                    document.body.removeChild(testElement);
                };
                
                testElement.addEventListener('touchstart', (e) => {
                    touchStartTime = performance.now();
                }, { passive: true });
                
                testElement.addEventListener('touchend', (e) => {
                    touchEndTime = performance.now();
                    const latency = Math.round(touchEndTime - touchStartTime);
                    document.getElementById('touchLatency').textContent = latency;
                    
                    if (latency < 100) {
                        this.logResult(`è§¸æ§å»¶é²å„ªç§€: ${latency}ms`, 'pass', 'mobileResults');
                    } else if (latency < 200) {
                        this.logResult(`è§¸æ§å»¶é²è‰¯å¥½: ${latency}ms`, 'warning', 'mobileResults');
                    } else {
                        this.logResult(`è§¸æ§å»¶é²è¼ƒé«˜: ${latency}ms`, 'fail', 'mobileResults');
                    }
                    
                    setTimeout(cleanup, 1000);
                }, { passive: true });
                
                testElement.addEventListener('click', (e) => {
                    if (touchStartTime === 0) {
                        // æ»‘é¼ é»æ“Šæ¸¬è©¦
                        const clickTime = performance.now();
                        document.getElementById('touchLatency').textContent = '< 16 (æ»‘é¼ )';
                        this.logResult('æ»‘é¼ é»æ“Šå»¶é²æ¥µä½', 'pass', 'mobileResults');
                        setTimeout(cleanup, 1000);
                    }
                });
                
                document.body.appendChild(testElement);
                
                // 5 ç§’å¾Œè‡ªå‹•æ¸…ç†
                setTimeout(() => {
                    if (document.body.contains(testElement)) {
                        cleanup();
                        document.getElementById('touchLatency').textContent = 'æœªæ¸¬è©¦';
                    }
                }, 5000);
            }
            
            // æ¸¬è©¦ç¶²è·¯é€Ÿåº¦
            async testNetworkSpeed() {
                try {
                    const startTime = performance.now();
                    const response = await fetch(window.location.href + '?cache=' + Date.now());
                    const endTime = performance.now();
                    
                    const loadTime = Math.round(endTime - startTime);
                    
                    if (loadTime < 100) {
                        this.logResult(`ç¶²è·¯é€Ÿåº¦å¿«: ${loadTime}ms`, 'pass', 'mobileResults');
                    } else if (loadTime < 500) {
                        this.logResult(`ç¶²è·¯é€Ÿåº¦ä¸­ç­‰: ${loadTime}ms`, 'warning', 'mobileResults');
                    } else {
                        this.logResult(`ç¶²è·¯é€Ÿåº¦æ…¢: ${loadTime}ms`, 'fail', 'mobileResults');
                    }
                } catch (error) {
                    this.logResult('ç¶²è·¯æ¸¬è©¦å¤±æ•—', 'fail', 'mobileResults');
                }
            }
            
            // æ¸¬è©¦æ»¾å‹•æ•ˆèƒ½
            testScrollPerformance() {
                let scrollCount = 0;
                let smoothScrolling = true;
                
                const testScroll = () => {
                    scrollCount++;
                    
                    if (scrollCount > 10) {
                        window.removeEventListener('scroll', testScroll);
                        document.getElementById('scrollPerf').textContent = smoothScrolling ? 'æµæš¢' : 'å¡é “';
                        
                        if (smoothScrolling) {
                            this.logResult('æ»¾å‹•æ•ˆèƒ½è‰¯å¥½', 'pass', 'mobileResults');
                        } else {
                            this.logResult('æ»¾å‹•æ•ˆèƒ½éœ€è¦æ”¹å–„', 'warning', 'mobileResults');
                        }
                    }
                };
                
                window.addEventListener('scroll', testScroll, { passive: true });
                
                // æ¨¡æ“¬æ»¾å‹•
                window.scrollBy(0, 10);
                setTimeout(() => window.scrollBy(0, -10), 100);
            }
            
            // CSS åŠŸèƒ½æ¸¬è©¦
            runCSSTest() {
                console.log('ğŸ¨ é–‹å§‹ CSS åŠŸèƒ½æ¸¬è©¦...');
                
                const cssTests = [
                    { name: 'CSS Grid', property: 'display', value: 'grid' },
                    { name: 'CSS Flexbox', property: 'display', value: 'flex' },
                    { name: 'CSS Transform', property: 'transform', value: 'translateX(10px)' },
                    { name: 'CSS Transition', property: 'transition', value: 'all 0.3s ease' },
                    { name: 'CSS Animation', property: 'animation', value: 'none' },
                    { name: 'CSS Filter', property: 'filter', value: 'blur(1px)' },
                    { name: 'CSS Backdrop Filter', property: 'backdrop-filter', value: 'blur(10px)' },
                    { name: 'CSS Custom Properties', property: '--custom', value: 'test' },
                    { name: 'CSS Clip Path', property: 'clip-path', value: 'circle(50%)' },
                    { name: 'CSS Object Fit', property: 'object-fit', value: 'cover' }
                ];
                
                const resultsDiv = document.getElementById('cssTestResults');
                resultsDiv.innerHTML = '';
                
                cssTests.forEach(test => {
                    const supported = CSS.supports(test.property, test.value);
                    const className = supported ? 'pass' : 'fail';
                    const status = supported ? 'âœ… æ”¯æ´' : 'âŒ ä¸æ”¯æ´';
                    
                    resultsDiv.innerHTML += `
                        <div class="test-result ${className}">
                            <strong>${test.name}:</strong> ${status}
                        </div>
                    `;
                });
            }
            
            // è¨˜éŒ„æ¸¬è©¦çµæœ
            logResult(message, type, containerId = 'testResults') {
                const container = document.getElementById(containerId);
                if (container) {
                    const div = document.createElement('div');
                    div.className = `test-result ${type}`;
                    div.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                    container.appendChild(div);
                }
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        }
        
        // åˆå§‹åŒ–æ¸¬è©¦å™¨
        const perfTester = new PerformanceTester();
        
        // å…¨åŸŸå‡½æ•¸
        function runPerformanceTest() {
            perfTester.runPerformanceTest();
        }
        
        function runMemoryTest() {
            perfTester.runMemoryTest();
        }
        
        function runAnimationTest() {
            perfTester.runAnimationTest();
        }
        
        function runCompatibilityTest() {
            perfTester.runCompatibilityTest();
        }
        
        function runMobileTest() {
            perfTester.runMobileTest();
        }
        
        function runCSSTest() {
            perfTester.runCSSTest();
        }
        
        // é é¢è¼‰å…¥å®Œæˆå¾Œè‡ªå‹•åŸ·è¡ŒåŸºæœ¬æ¸¬è©¦
        window.addEventListener('load', () => {
            console.log('ğŸ“Š é é¢è¼‰å…¥å®Œæˆï¼Œé–‹å§‹è‡ªå‹•æ¸¬è©¦...');
            
            // å»¶é²åŸ·è¡Œä»¥ç¢ºä¿æ‰€æœ‰è³‡æºè¼‰å…¥å®Œæˆ
            setTimeout(() => {
                runPerformanceTest();
                runCompatibilityTest();
                runCSSTest();
            }, 1000);
        });
        
        // ç›£æ§é•·æ™‚é–“æ•ˆèƒ½
        setInterval(() => {
            if (performance.memory) {
                const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                document.getElementById('memoryUsage').textContent = memoryMB;
            }
        }, 5000);
    </script>
</body>
</html>